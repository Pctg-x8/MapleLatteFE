# Maple Latte Language Specification

メモ的な感じに

### Sample Script(sample.mls)
```
package maple.sample.hello;

// Java側のクラスを持ってくる(mainメソッド用)
import java.lang;

// スクリプト内プライベートクラスの宣言
bound class HelloWriter
{
	// 返り値の推論(この場合はvoid)
	public run()
	{
		maple.io.writeln("Hello, World.");
	}
}

// ここから下はprivate static class globalの
// 静的初期化子の中身として展開される(privateは「外部パッケージからアクセスできない」を示す)
// globalはスクリプトのキーワードなのでユーザーがクラス宣言することはできない
// valは定数(代入不可)宣言、変数を宣言する場合はvarもしくは型を明示する
// valの代わりにconstも使える(型を明示して定数を宣言するにはconstを使うしかない)
val o = new HelloWriter();
o.run;

// globalクラスの(デフォルト)public staticメンバとして宣言される
void main(String[] args)
{
	// これがないとJavaで実行できない(引数もこれじゃないとダメ)
}
// 以下はエラー
// static void main()

// 実行
// > mlfe -emit=java sample.mls #-emit=javaは省略できる(デフォルト)
// > java maple.sample.hello.global
// もしくは
// > mlfe -emit=llvm sample.mls
// > lli sample.bc
```

## Summary(簡単に)

主にD言語とScalaに影響を受けた言語です。  
当面の間はJVM上で動くコンパイル最速言語を目標にします。

## Structure

ソースファイルの構造
* 基本的には宣言(Declarator)を列挙していく
* 先頭にパッケージ宣言(SourcePackageDeclarator, `package <パッケージ名>;`)を書くことができる
  * 効果範囲はソースコード全体
* クラスファイル宣言(SourceClassDeclarator, `class <パッケージ名(省略可)>.<クラス名>;`)を書くと、ファイル全体をクラス内で宣言したものにできる
  * `trait`も同様

## Declarator

### クラス定義
`class <クラス名> extends <親クラス/トレイト名> with <トレイト名> with <トレイト名>...`
* extends節、with節は省略可能

### トレイト定義
`trait <トレイト名> with <トレイト名> with <トレイト名>...`
* with節は省略可能

### 列挙子定義
`enum <列挙子名>`
* Javaのenumと同じであるが、定数以外の宣言を行うことはできない(ので継承も不可)

### テンプレート定義
`template <テンプレート名>(<テンプレート引数>...)`
* コンパイル時に展開される
* ジェネリクスも使用できる(クラス名、トレイト名の後ろに`[<ジェネリクス引数>...]`をつける)
* ジェネリクスは型のみ受け付けるが、テンプレートはコンパイル時に決定できるあらゆるものを受け取ることができる
* テンプレート中に同名のクラス、トレイトを宣言した場合は暗黙的にそのクラス、トレイトとして使用できる
* テンプレート名を省略した場合、次に続く宣言と同名であるものとする
  * 複数宣言が存在した場合はエラーにする
  
## Template instantiation
`<テンプレート名>#<テンプレート引数>` または `<テンプレート名>#(<テンプレート引数リスト>)`
* テンプレート、ジェネリクスともに共通の実体化構文を使う
  * そのため、テンプレートとジェネリクスを同時に使用することはできない
  * ネストは可能なため、ひとつの名に対して同時に使用されない場合は(`LinkedListWrapper#(ArrayList#String)`等)問題は発生しない
* 括弧でくくらない場合は、次の一つのシンボルのみ引数として認識される
  * `LinkedListWrapper#(String[])`と`LinkedListWrapper#String[]`は意味が異なる(後者は`LinkedListWrapper#String`の可変長配列とみなされる)

## Expression

一般的な演算子(四則演算、ビット/論理演算、比較演算、三項演算子)が使用できる。
優先順位は以下の表の通り(高いほど先に計算される)。

|優先度|演算子|
|---|---|
|高|*,/,%|
||+,-|
||&amp;,&#124;,^|
||&lt;&lt;,&gt;&gt;|
||==,!=,&lt;,&gt;,&lt;=,&gt;=|
||&amp;&amp;,&#124;&#124;|
|低|?:|

()でくくることにより優先順位を上昇させることができる。

### new式
`new <型>[<要素数>](<コンストラクタ引数>)`  
* オブジェクト(参照型)の作成にはnewを使う
* 要素数の指定とコンストラクタ引数はともに括弧ごと省略可能である
  * 要素数自体の省略も可能(可変長配列をnewする場合)
* 多次元配列(配列の配列)を作成する場合は要素数の指定を連ねる

### ラムダ式/無名関数
`<引数> => <式> (一番簡単な例)`  
`(<引数リスト>) => <式> (複数の引数を受け取る場合)`  
`(<引数リスト>) <文ブロック> (文を含む場合)`
* 式を直接書いた場合はreturnを省略したものとする
* 文ブロックを書く場合は`=>`は不要
  * ブロックなので`{}`で囲う必要がある
* `(<引数リスト>) => <式>`は`(<引数リスト>){ return <式>; }`と同じである。  
また、`(<引数>) => <式>`と`<引数> => <式>`も同じである

### match式
`match(<式>) { <case節>/<default節>... }`  
case節: `case <式リスト> => <式>;` または `case <束縛変数> : <プレースホルダ型>, <型変数> : <型>... => <式>;`  
default節: `default => <式>;`
* 値を持ち、式の中で使用可能なswitch
* ひとつのcase節で複数の式を指定した場合はorで繋がれたものとする(一つでも合致すればその式の値が返る)
* どのcaseにもマッチせず、default節がない場合は実行時エラーとなる
* 束縛変数は_とすることで使用されないことを表明できる(複数のcaseで重複してもエラーにならない)
